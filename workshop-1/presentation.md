---
author: Shivaraj
date: MMMM dd, YYYY
paging: Slide %d / %d
---

# Nix expression language (workshop-1)
## Let's learn Nix by writing a derivation from scratch!

---

## Quick Recap
### What is an attribute set?
```nix
{ foo = 1; bar = 2; }
```
### How do you define a function?
```nix
# Single parameter
foo: foo*2
# Multiple parameters
foo: bar: foo + bar
# Above is equivalent to
foo: (bar: foo + bar)
# Attrset as a parameter
{ foo, bar }: foo + bar
```
---
### Imports
examples/a.nix
```nix
{ x?1, y?2 }: x + y
```
examples/b.nix
```nix
{ i = import ./a.nix {}; j = import ./a.nix { x = 3; y = 4}; }
```
---
### Evaluate
```bash
nix eval -f workshop-1/examples/b.nix i
nix eval -f workshop-1/examples/b.nix j
```
---

## Builtin functions in Nix
### builtins attrset is a collection of all the builtin functions
### Example functions from builtins
```nix
map :: (a -> b) -> [a] -> [b]
```
For example:
```nix
map (x: "hello" + x) [ "world" "nix" ]
```
evaluates to
```nix
[ "helloworld" "hellonix" ]
```
---
### One more example
```nix
mapAttrs :: (a -> b -> c) -> AttrSet -> AttrSet
```
For example:
```nix
mapAttrs (name: value: name + value) { foo = "bar"; hello = "world"; }
```
evaluates to
```nix
{ foo = "foobar"; hello = "helloworld"; }
```
---
### And a couple more
```nix
concatLists :: [List] -> []
readFile :: Path -> String
```
### Search engine for all the builtin functions and more
https://noogle.dev/
---
## Derivation
### What is a derivation?
- It is a function in `builtins`. You can also access it without `builtins.derivation` because it is aliased to `derivation`.
- It takes an attribute set as an argument. The attribute set must have the following attributes:
  - `name`: The name of the derivation
  - `builder`: The path to the builder script
  - `system`: The system for which the derivation is built
```nix
nix-repl> derivation { name = "myderivation"; builder = "mybuilder"; system = "mysystem"; }
«derivation /nix/store/vc5j8bwssr3dq8zjlkyc78pd4fm89jk0-myderivation.drv»
```
---
### Visualise the derivation
```bash
nix show-derivation /nix/store/vc5j8bwssr3dq8zjlkyc78pd4fm89jk0-myderivation.drv 
```

---
### Build the derivation
#### Spoiler alert! We will create the derivation but it won't actually build.
```nix
nix-repl> :b derivation { name = "myderivation"; builder = "mybuilder"; system = "mysystem"; } 
 error: a 'mysystem' with features {} is required to build '/nix/store/vc5j8bwssr3dq8zjlkyc78pd4fm89jk0-myderivation.drv'
 , but I am a 'aarch64-darwin' with features {benchmark, big-parallel, nixos-test}
```
#### `mybuilder` is not a valid builder. It has to be an executable.
#### `mysystem` is not a valid system.
##### Check the output of `builtins.currentSystem` to see what your system is
##### Internally it calls `uname -m` and `uname -s`. `uname` is a command line utility to print system information.
---
### Build a working derivation
#### Previous derivation failed to build because of invalid builder. Let's fix that!
#### We will be using `bash` as our builder from `nixpkgs`. Before that, let's understand what `nixpkgs` is.
#### You can think of `nixpkgs` as a collection of packages. These packages are created by writing derivations. 
Here's a basic script that uses `bash` as the builder:
```bash
# workshop-1/examples/builder.sh
declare -xp
echo "Hello World!" > $out
```
`$out` is the path generated by nix for the output of the derivation. It has to be a file or folder. In this case, it is a file.

Let's build it:
```nix
nix-repl> :lf github:nixos/nixpkgs
nix-repl> bash = outputs.legacyPackages.aarch64-darwin.bash
nix-repl> bash
«derivation /nix/store/9xq9iv8mx8fzlhs9lq25654wz0smylvm-bash-5.2-p15.drv»
nix-repl> :b derivation { name = "myderivation"; builder = "${bash}/bin/bash"; args = [ ./workshop-1/examples/builder.sh ]; 
          system = builtins.currentSystem; }
 This derivation produced the following outputs:
  out -> /nix/store/58lzg17rjhzlkf8akghb2bqgpcmbc1vp-myderivation
```
---
### Let's analyze the previous derivation
#### Couple of observations you would've made:
- derivation hash has changed compared to the previous one
- Our derivation is built and the output stored in `$out`.

Here's what the file contains:
```bash
cat /nix/store/58lzg17rjhzlkf8akghb2bqgpcmbc1vp-myderivation
# Hello World!
``` 
#### What about the `declare -xp` in the builder script?
Since we have not directed the output to a file, it is printed to the console during the build process. To see the build log, run:
```bash
nix log /nix/store/58lzg17rjhzlkf8akghb2bqgpcmbc1vp-myderivation
```
---
### What does the output of `declare -xp` denote?
```bash
declare -x HOME="/homeless-shelter"
declare -x NIX_BUILD_CORES="8"
declare -x NIX_BUILD_TOP="/private/tmp/nix-build-myderivation.>
declare -x NIX_LOG_FD="2"
declare -x NIX_STORE="/nix/store"
declare -x OLDPWD
declare -x PATH="/path-not-set"
declare -x PWD="/private/tmp/nix-build-myderivation.drv-0"
declare -x SHLVL="1"
declare -x TEMP="/private/tmp/nix-build-myderivation.drv-0"
declare -x TEMPDIR="/private/tmp/nix-build-myderivation.drv-0"
declare -x TERM="xterm-256color"
declare -x TMP="/private/tmp/nix-build-myderivation.drv-0"
declare -x TMPDIR="/private/tmp/nix-build-myderivation.drv-0"
declare -x builder="/nix/store/f2fi9x1fnwly702yqdlsjhy46pcgz5v>
declare -x name="myderivation"
declare -x out="/nix/store/58lzg17rjhzlkf8akghb2bqgpcmbc1vp-my>
declare -x system="aarch64-darwin"
```
#### The above output is partly the reason behind the isolated builds in nix.

---
## Package GNU hello 
### As step-0 we will get the source code URL and use `builtins.fetchurl` to create a nix store path with the source.
```nix
nix-repl> builtins.fetchurl { url = "https://ftp.gnu.org/gnu/hello/hello-2.12.tar.g
z"; }
"/nix/store/8nqv6kshb3vs5q5bs2k600xpj5bkavkc-hello-2.12.tar.gz"
```
---
### Step-1: Builder script
```bash
# Stop the build if any command fails
set -e
# Export only the required binaries into the PATH
export PATH="$gnutar/bin:$gzip/bin:$gcc/bin:$gnumake/bin:$gnused/bin:$coreutils/bin:$bintools/bin:$gnugrep/bin:$gawk/bin"
# Unpack Phase
tar -xzf $src
cd hello-2.12
# Configure Phase
./configure --prefix=$out
# Build Phase
make
# Install Phase
make install
```
---
### Step-2: Create a derivation

### Step-2.1: Inputs
```nix
{
  inputs.nixpkgs.url = "github:nixos/nixpkgs";
}
```
### Step-2.2: Packages for your system
```nix
let
  pkgs = nixpkgs.legacyPackages.aarch64-darwin;
in
```
---
### Step-2.3: Define your derivation
```nix
let
  drv = derivation {
    name = "myHello";
    builder = "${pkgs.bash}/bin/bash";
    args = [ ./hello_builder.sh ];
    system = "aarch64-darwin";
    src = builtins.fetchurl 
    { 
      url = "https://ftp.gnu.org/gnu/hello/hello-2.12.tar.gz"; 
      sha256 = "1ayhp9v4m4rdhjmnl2bq3cibrbqqkgjbl3s7yk2nhlh8vj3ay16g";    
    };
    # gnutar is needed to unpack the source
    gnutar = pkgs.gnutar;
    # gnutar depends on gzip
    gzip = pkgs.gzip;
    # Compiler
    gcc = pkgs.clang;
    # Build tools
    gnumake = pkgs.gnumake;
    # Packages below are needed during the configuration phase.
    # During this phase the Makefile is generated
    inherit (pkgs) gnused coreutils gnugrep gawk;
    bintools = pkgs.clang.bintools.bintools_bin;
  };
in
```
---
### Step-2.4: Outputs
```nix
{
  outputs = { self, nixpkgs }: {
    packages.aarch64-darwin.default = 
    let
      pkgs = ...;
      drv = ...;
    in
      drv;
  };
}
```
---
### show-derivation
```nix
nix-repl> :lf .
Added 10 variables.
nix-repl> outputs.packages.aarch64-darwin.default
«derivation /nix/store/nlyh1b0112ihi3fvv3xwdia80fisdcsc-myHello.drv»
```
```bash
nix show-derivation /nix/store/nlyh1b0112ihi3fvv3xwdia80fisdcsc-myHello.drv
```
#### Output is too long to fit in the slide. Let's execute the command in the terminal and have a look at the output.
---
### Build the derivation with `nix build` 
```bash
nix build --print-out-paths
/nix/store/s0hj1mbmxs1m4l2py6cgln5g0nmyrd7i-myHello
```
<!-- Notice how the nix store path is same as `outputs.out` in nix show-deivation output. -->
---
## Upcoming!
### We will see how to utilise multiple derivations (like postgres, postgREST) to build a web server that interacts with the database.
<!-- Show demo of process-compose-flake quick example as a preview -->


